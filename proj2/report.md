# گزارش پروژه‌ی دوم شبیه سازی

+ روزبه شریف نسب 97243093
+ متین زیودار 972430



# فاز ۱



مراحلی که برای انجام فاز ۱ دنبال شد به شکل زیر است:



## تابع irreducible

اولین قدم برای ما این بود که تشخیص دهیم یک تابع irreducible هست یا نه. در ابتدا با توجه به دانسته ها و گفته های صورت پروژه اقدام به پیاده سازی دقیق الگوریتم خواسته شده کردیم. 

برای این کار از numpy استفاده شد.

اما در ادامه متوجه شدیم که چنین تابعی در خود networkx پیاده سازی شده و بهتر و دقیق تر است که از همین تابع استفاده کنیم. در نهایت تابع ما چیزی شبیه تصویر زیر شد: 

![image-20220520185302261](report.assets/image-20220520185302261.png)

نکته چالش بر انگیز این قسمت پیدا کردن الگوریتم مورد نظر در کتابخانه networkx بود.



## انجام یک بار آزمایش

دومین گام ساخت یک گراف ER و انجام ازمایش برای p های مختلف بود. یک ارایه نامپای از p های مختلف درست شد.

سپس به ازای هر p شبیه سازی انجام شد. اما مجبور بودیم که فقط یک n را بگیریم در این مرحله.

## ساخت گراف 

در صورت سوال از ما ۳ نوع گراف مختلف خواسته شده بود.

برای اینکه بتوانیم این گراف ها را بسازیم از توابع networkx استفاده کردیم.

اما مشکل این بود که کاربر قرار بود مشخص کند چه گرافی ساخته شود. برای این منظور یک map از کلیدی که کاربر وارد می‌کرد به تابع (lambda)یی که گراف مربوطه را می‌ساخت ساختیم. 

![image-20220520190105423](report.assets/image-20220520190105423.png)

البته کمی این قسمت چالش برانگیز است که در جلوتر توضیح می‌دهیم.



## انجام ازمایش برای گراف های مختلف و n های مختلف در p های مختلف 

قدم بعدی این بود که از این گراف های ساخته شده استفاده کنیم و همچنین n متغیر را بگیریم. برای این منظور ۱۰ n متفاوت در نظر گرفته شد که ازمایش را برای هر کدام از این n ها تکرار کردیم.

سپس با کمک کتابخانه matploitlib یک فیگور ۱۰ تایی ساخته شد که در هر کدام یک n بررسی می‌شود. 



## محاسبه به کمک روش تئوری 

در نهایت محاسبه به کمک تئوری نیز حساب شد. 

یکی از قسمت های تئوری متاسفانه همانطور که گفته شد بسیار زمان بر بود (تصویر زیر)

هرچند که توابع کمکی خوبی نیز در networkx وجود داشت برای نمونه تمام زیر گراف ها اما محاسبه به ازای هر کدام بسیار زمان بر می شد. بنابراین فعلا از رسم گراف برای آن طرف نظر شد

![image-20220520190503429](report.assets/image-20220520190503429.png)

در این قدم روش محاسبه‌ای بر اساس فرمول به گراف اضافه گردید.



## تعداد تکرار epoch

کار ما اما همینجا تمام نمی شود. کاری که باید انجام دهیم تکرار شبیه سازی است. با تکرار شبیه سازی به تعداد بالا به کمک قانون اعداد بزرگ از صحت جواب هایمان مطمئن می‌شویم و نویز خروجی را کاهش می‌دهیم.

برای اینکار از همان epoch گفته شده در صورت سوال استفاده شد. 

در هر مرحله به تعداد گفته شده گراف ساخته می‌شد و بینشان میانگین معمولی (جبری) گرفته می شد و آن عدد به عنوان معیار دخیره می‌شد.



## بررسی نتایج

اکنون که شبیه سازی برای این فاز تمام شده نوبت به تفسیر و بررسی نتایج می‌رسد.

بهترین حالت  برای شباهت تئوری و شبیه سازی گراف های ER است. مخصوصا در تعداد n های بالا می‌بینیم که بسیار به هم نزدیک شده اند و نتیجه بسیار خوب است. 



نتیجه n های مختلف برای گراف ER

![ER](report.assets/ER.png)



اما متاسفانه برای گراف های BA و ES به چنین نتیجه خوبی نرسیدیم. 

(تصاویر زیر)

دلیل این امر می‌تواند این باشد که ما با داشتن n,p راحت می‌توانستیم گراف ER رسم کنیم اما در گراف های دیگر پارامترها با N,P که ما داشتیم شباهت نداشتند و مجبور بودیم به روش تقریبی و چشمی آن ها را تولید کنیم و احتمالا در این مورد اشتباه کرده ایم.





![BA](report.assets/BA.png)

![WS](report.assets/WS.png)

